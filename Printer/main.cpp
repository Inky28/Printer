/*
Декілька користувачів мережі друкують свої документи на одному мережевому принтері.
В один момент часу принтер може друкувати лише один документ.
На друк документа іде певний час, для кожного документа свій ( rand() ).
Протягом усього цього часу принтер "зайнятий" і не може приймати нового завдання.
Якщо, поки принтер "зайнятий", якийсь користувач відправляє документ на друк, то цей, новий, документ ставиться у чергу друку.
Як тільки принтер завершить друк документа, він стає "вільний" і може прийняти інший документ і почати його друкувати.

Документи різних користувачів мають різний пріоритет.
Пріоритет документів "Директора" вищий від пріоритету документів "Бухгалтера",
а пріоритет документів "Бухгалтера" вищий від пріоритету документів "Клерка" і т. д.
Отже, коли у черзі є документи з різними пріоритетами, то на принтер з черги спершу виходять документи з вищим пріоритетом.

Треба реалізувати клас Spooler, котрий є пріоритетною чергою і може приймати документи з пріоритетом, та віддавати їх (пріоритетні в першу чергу)
Черга впорядковується при постановці -- новий документ вставляється перед першим документом  з нижчим пріоритетом, або в хвіст, якщо такого нема.

Документ -- окремий клас (Document), котрий "знає":
свою назву (Doc1.doc  -- можна використати XString )
свій розмір ( 23456 KB -- size_t )  -- від розміру залежатиме час його друку принтером
вміє : повідомити це все.

Принтер -- клас Printer, котрий знає:
екземпляр Spooler'а, у якого запитуватиме документи
документ, котрий друкує в даний момент
скільки часу залишилося до завершення, або момент завершення (Щоб був прогресбар)
Треба зробити меню, щоб ставити документ з різним пріоритетом у чергу, а потім запустити їх на друк
*/

#include <iostream>
#include <string>
#include <ctime>
#include "Document.h"
#include "Spooler.h"

using namespace std;

class Printer
{
private:
	Spooler<Document> value;

public:
	void AddDoc(Document& doc)
	{
		value.Push(doc);
	}

	int GetTimeForDoc()
	{
		return value.GetItem().GetSize() / 10 + rand() % 10;
	}
};

int main()
{
	srand((unsigned)time(nullptr));


	return 0;
}